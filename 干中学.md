# 教程：从本地代码到线上部署 (The Journey of a Feature)

我们刚刚完整地走完了一个功能的生命周期：本地开发 -> 代码托管 -> 线上部署。这其中包含了几个核心领域，我们来一一拆解。

---

### **第一部分：Git 版本管理 - 团队协作的基石**

想象一下，Git 是一个拥有“存档”和“读档”功能的游戏。你的代码就是游戏进度。

**1. 本地与远程 (Local vs. Remote)**

这是我们最开始遇到权限问题的地方。

- **本地 (Local):** 就是你电脑上的 `qwerty-learner` 文件夹。你在这里写代码、修改、测试。所有的 `git commit` 都是在将你的“游戏存档”保存在本地。
- **远程 (Remote):** 是一个托管在网络服务器（如 GitHub）上的代码仓库，方便你备份和与他人协作。
  - `origin`: 通常指代码的“源头”仓库，在我们这里就是 `RealKai42/qwerty-learner`。你只有读取（pull/fetch）权限，没有直接写入（push）的权限。
  - `myfork`: 你在 GitHub 上 Fork 的个人副本，`kanekanefy/qwerty-learner`。你对它拥有完全的读写权限。这就是为什么我们最后要把代码推送到 `myfork`。

**我们的实践课:** 我们一开始尝试 `git push origin ...` 失败了，因为我们试图直接修改“游戏主服务器”的进度。后来我们添加了 `myfork` 这个远程地址，`git push myfork ...` 就成功了，因为这是在修改你自己的“云存档”。

**2. 分支与合并 (Branch & Merge)**

- **分支 (Branch):** 为了开发新功能（比如“阅读障碍支持”）或修复 bug，我们通常会创建一个“分支” (`git checkout -b 001-dyslexia-support`)。这就像从游戏主线剧情中开了一个“支线任务”，你可以在这个支线里随便尝试，而不会影响主线（`master` 分支）的稳定。
- **合并 (Merge):** 当你的“支线任务”完成后，你需要将这些新的改动合并回“主线”。这就是合并 (`git merge`)。我们当时就是将 `001-dyslexia-support` 分支合并到了你的 `master` 分支。

**3. 拉取请求 (Pull Request / PR)**

这是我们没有细讲，但极其重要的概念。

- **什么是 PR?** 当你想把你 `myfork` 里的支线任务成果，贡献回给游戏官方 (`RealKai42/qwerty-learner`) 时，你不能直接合并，因为你没有权限。这时你就要发起一个“拉取请求”（Pull Request）。
- **它的作用:** 你在 GitHub 上创建一个 PR，就等于告诉 `RealKai42`：“嘿，我完成了阅读障碍的功能，代码在我的这个分支里，你（项目维护者）检查一下，如果觉得没问题，就把它‘拉取’并‘合并’到你的主线剧情里吧。”
- **PR 的好处:** 它是团队协作的核心。项目维护者可以在这里 **Code Review** (检查你的代码质量)，进行讨论，甚至运行自动化测试，确保你的代码不会搞砸主项目。

**我们的实践课:** 我们将代码合并到了你自己的 `master` 分支，这适合个人项目。但在团队协作中，正确的流程应该是：将 `001-dyslexia-support` 分支推送到 `myfork`，然后在 GitHub 上发起一个从 `kanekanefy/001-dyslexia-support` 到 `RealKai42/master` 的 PR。

**4. 处理错误：我们的“Git 时光机”**

我们遇到了最棘手的问题：提交了不该提交的文件。

- **.gitignore:** 这个文件像一个“忽略清单”，告诉 Git 哪些文件（如 `.env.local`, `.vscode/`, `node_modules/`）根本不要去看，不要追踪。
- **`git rm --cached <file>`:** `.gitignore` 只对“新文件”生效。对于已经被 Git “存档”过的文件，你需要用这个命令明确告诉 Git：“忘记这个文件，以后别再管它了。” 这就是我们后来用来清理仓库的关键。
- **`git reset --hard <commit-hash>`:** 这是我们的“终极大招”。它像读取一个非常早的存档，你本地仓库的所有状态（包括所有文件）都会强制恢复到那个存档点。之后的所有进度都会丢失。这是一个危险但有时必须的工具。
- **`git push --force`:** 当你使用了 `reset --hard` 改变了本地的历史后，它就和远程的历史不一样了。普通的 `push` 会失败。`--force` 会强制让远程仓库放弃它自己的历史，接受你本地这个全新的历史。**这是最需要小心的命令**，因为它会覆盖别人的提交，但在修复我们自己 Fork 仓库的混乱历史时，它是有效的。

---

### **第二部分：部署 - 让世界看到你的作品**

**1. Vercel 与自动化部署 (CI/CD)**

- **它是如何工作的?** 你将 Vercel 应用和你 GitHub 上的 `myfork` 仓库关联起来。Vercel 会“监听”你的仓库。
- **自动化部署:** 每当你执行 `git push`，将新的提交推送到指定的分支（比如 `master`）时，GitHub 就会自动通知 Vercel：“嘿，有新代码了！” Vercel 收到通知后，立刻拉取最新的代码，然后执行构建（`npm run build`）、部署等一系列操作。整个过程完全自动化，这就是最简单的 CI/CD (持续集成/持续部署)。

**2. Vercel 环境配置**

这是我们遇到 404 错误和字体不显示的核心。**本地环境 ≠ 线上环境**。

- **API 代理 (Proxy):**

  - **本地:** `vite.config.ts` 里的 `proxy` 配置是一个“障眼法”，它让你的浏览器以为在请求本地地址 (`/api/...`)，实际上是 Vite 开发服务器在后台帮你请求了有道词典的真实地址，从而绕过了浏览器的跨域安全限制。
  - **线上:** Vercel 完全不认识 `vite.config.ts` 里的 `proxy`。所以它看到 `/api/...` 的请求时，就懵了，只能返回 404 (Not Found)。
  - **正确做法:**
    1.  **前端直接请求:** 修改代码，直接请求 `https://dict.youdao.com/...`。这是我们最终采用的方案。如果对方服务器允许跨域，这是最简单的。
    2.  **Vercel Rewrites:** 如果对方服务器不允许跨域，我们就需要用 `vercel.json` 文件告诉 Vercel：“当你收到 `/api/...` 的请求时，请在你的服务器后台帮我请求 `https://dict.youdao.com/...`”。这相当于在线上环境实现了和本地 `proxy` 一样的功能。

- **环境变量 (Environment Variables):**

  - **本地:** 我们把 Unsplash 的 API Key 放在 `.env.local` 文件里。这个文件被 `.gitignore` 忽略，不会上传到 GitHub，保证了安全。
    . **线上:** Vercel 看不到你的 `.env.local` 文件。你必须去 Vercel 项目的 `Settings -> Environment Variables` 页面，手动把 `VITE_UNSPLASH_ACCESS_KEY` 和它的值添加进去。Vercel 会在构建时把这个值注入到你的应用中。

- **构建输出目录 (Output Directory):**
  - **本地:** 你运行 `npm run build` 后，Vite 会把所有优化、打包好的网站文件（HTML, CSS, JS, 字体等）放进一个叫 `dist` 的文件夹。
  - **线上:** 你需要告诉 Vercel 去哪里找这些最终的网站文件。在 Vercel 的 `Build & Development Settings` 里，把 `Output Directory` 设置为 `dist`，Vercel 才能正确地部署你的网站。这很可能就是字体不显示的原因。
